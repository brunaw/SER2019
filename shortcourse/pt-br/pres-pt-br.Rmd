---
title: "Análise de dados musicais no `R`"
subtitle: "IV Seminário Internacional de Estatística com `R`"
author: Bruna Wundervald & Julio Trecenti
date: Maio, 2019
output:
  xaringan::moon_reader:
    css: ["default", "css/my-theme.css", "css/my-fonts.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "https://platform.twitter.com/widgets.js"
    includes:
      in_header: header.html  
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center',
                      warning = FALSE, message = FALSE, 
                      eval = FALSE, cache = TRUE)
library(tidyverse)
```

# Quem somos

.pull-left[
```{r, echo = FALSE, out.width="70%", eval = TRUE}
knitr::include_graphics("img/bruna.jpg")
```
] .pull-right[
**Bruna Wundervald**
- Doutoranda em Estatística na Maynooth University.
- Twitter: @bwundervald
- GitHub: @brunaw
]

---
# Quem somos

.pull-left[
```{r, echo = FALSE, out.width="70%", eval = TRUE}
knitr::include_graphics("img/jubs.png")
```
].pull-right[
  **Julio Trecenti**
  - Doutorando em Estatística no IME-USP
  - Sócio da Curso-R
  - Twitter: @jtrecenti
  - GitHub: @jtrecenti

  ]

---
# Objetivos

  - Aprender a utilizar os pacotes:
    - `vagalumeR`: extração de letras
    - `chorrrds`: extração de acordes 
    - `Rspotify`: extração de variáveis da [API do Spotify](https://developer.spotify.com/documentation/web-api/)
    
  - Entender como funciona a acesso a APIs em geral.
  - Conectar dados de diferentes fontes.
  - Compreender e resumir dados de diferentes formatos:
    - Texto
    - Contínuos
    - Sequências
  - Aprender a criar e interpretar um modelo de predição simples. 

**Não abordado neste curso:** análise de áudio. 

---
# Requisitos & recursos

   - `R` iniciante/intermediário 
   - `tidyverse`
   - `%>%` (pipe) é essencial! 
    
[**R-Music Blog**](https://r-music.rbind.io/) <img src="https://raw.githubusercontent.com/r-music/site/master/img/logo.png" style="float:left;margin-right:20px;" width=120>

<h4 style="padding:0px;margin:10px;">
R para extração & análise de dados musicais
</h4>

---

# Carregando pacotes

Principais: 
```{r, eval = FALSE}
library(vagalumeR)
library(Rspotify)
library(chorrrds)
library(tidyverse)
```

---
# Conectando às APIs
## `vagalumeR`
Passos:
  1. Entrar em `https://auth.vagalume.com.br/ ` e logar,
  2. Entrar em `https://auth.vagalume.com.br/settings/api/` e criar um 
  aplicativo,
  3. Entrar em `https://auth.vagalume.com.br/settings/api/` novamente 
  e copiar a credencial do aplicativo. 
  4. Salvar a credencial em um objeto, como:
  
```{r, eval = FALSE}
key_vagalume <- "minha-credencial"
```

---
# Conectando às APIs
## `Rspotify`

Passos:
  1. Entrar em `https://developer.spotify.com/` e logar, 
  2. Entrar em `https://developer.spotify.com/dashboard/` e criar um 
  aplicativo,
  3. Salvar o **client ID** e o **client Secret** gerados, 
  4. Definir a como URL de redirecionamento como `http://localhost:1410/`,
  5. Usar a função `spotifyOAuth` para autenticar o acesso:
  
```{r, eval = FALSE}
library(Rspotify)
key_spotify <- spotifyOAuth("app_id","client_id","client_secret")
```
  
> As chaves serão usadas posteriormente para nos dar acesso aos
dados provenientes das duas APIs.

---

class: bottom, center, inverse

# Extração de dados
## `vagalumeR`: letras de músicas 
## `RSpotify`: variáveis do Spotify
## `chorrrds`: acordes das músicas

---

# Introdução

- Para cada pacote, existe um fluxo a ser seguido.

- O fluxo envolve, basicamente, obter os IDs dos objetos dos quais
queremos as informações (como artistas, álbuns, músicas) e passar
estes IDs para funções específicas;


---

# `vagalumeR`


```{r, eval = FALSE}
# 1. Definir artista
artist <- "chico-buarque"

# 2. Buscar os nomes e IDS das músicas de um artista
songs <- artist %>% 
  purrr::map_dfr(songNames)

# 3. Mapear a função que traz as letras nos IDs encontrados  
lyrics <-  songs %>% 
  dplyr::pull(song.id) %>% 
  purrr::map(lyrics, 
             artist = artist,
             type = "id", 
             key = key_vagalume) %>%
  purrr::map_df(data.frame) %>% 
  dplyr::select(-song) %>% 
  dplyr::right_join(songs %>% 
                      dplyr::select(song, song.id), by = "song.id")
```

---

# `RSpotify`

```{r, eval = FALSE}
# 1. "Buscar" o artist usando a API
find_artist <- searchArtist("chico buarque", token = key_spotify)

# 2. Usar o ID encontrado para buscar informações dos albuns
albums <- getAlbums(find_artist$id[1], token = key_spotify)

# 3. Obter as músicas de cada albúm
albums_res <- albums %>% 
  dplyr::pull(id) %>% 
  purrr::map_df(
    ~{
      getAlbum(.x, token = key_spotify) %>% 
        dplyr::select(id, name) 
    }) %>% 
  tidyr::unnest()

ids <- albums_res %>% 
  dplyr::pull(id)

# 4. Obter as variáveis para cada música
features <- ids %>% 
  purrr::map_df(
    ~{
      getFeatures(.x, token = key_spotify) 
    }) %>% 
  dplyr::left_join(albums_res, by = "id")
```

---

**O pacote ainda não tem uma opção simples para encontrar a popularidade das músicas. Como resolver?**
```{r, eval = FALSE}
# 5. Criar uma função simples para pegar a popularidade
getPop <- function(id, token){
  req <- httr::GET(paste0("https://api.spotify.com/v1/tracks/", id), 
                   httr::config(token = token))
  json1 <- httr::content(req)
  res <- data.frame(song = json1$name, 
                    popul = json1$popularity, 
                    id = json1$id)
  return(res)
}

# 6. Mapear essa função nos IDs das músicas
popul <-  features %>% 
  dplyr::pull(id) %>% 
  purrr::map_df(
    ~{
      getPop(.x, token = key_spotify) 
    }) 

# 7. Juntar a popularidade com o resto das variáveis 
features <- features %>% 
  dplyr::right_join(
    popul %>% dplyr::select(-song), 
    by = c("id" = "id"))

```

---
# Detalhes sobre APIs

- ** Elas podem ser muito instáveis. Isso significa que algumas vezes, mesmo sem atingir o limite de consultas máximo, elas vão falhar.**

Como resolver? 

  - Dividir o processo em consultas menores
  - Colocar um pequeno intervalo de tempo entre as consultas, com
  `Sys.sleep()` por exemplo 
  
---

# `chorrrds`

```{r, eval = FALSE}
# 1. Buscar as músicas
songs <- "chico-buarque" %>% 
  chorrrds::get_songs() 

# 2. Mapear a extração de acordes nas músicas encontradas
chords <- songs %>% 
  dplyr::pull(url) %>%                     
  purrr::map(chorrrds::get_chords) %>%    
  purrr::map_dfr(dplyr::mutate_if, is.factor, as.character)   %>% 
  chorrrds::clean(message = FALSE) 
```


---

# Combinando as diferentes bases

```{r, eval = FALSE}
# Padronizar o nome da coluna chave e usar uma função de união, 
# como o inner_join()

chords <- chords %>% 
  dplyr::mutate(song = stringr::str_remove(music, "chico buarque ")) %>% 
  dplyr::select(-music)

lyrics <- lyrics %>% 
  dplyr::mutate(song = stringr::str_to_lower(song))

features <- features %>% 
  dplyr::mutate(song = stringr::str_to_lower(name)) %>% 
  dplyr::select(-name)

all_data <- chords %>% 
  dplyr::inner_join(lyrics, by = "song") %>% 
  dplyr::inner_join(features, by = "song")

```

---
**E se tiver muita coisa que não deu match?**

```{r, eval = FALSE}
nrow(chords) - nrow(all_data) 
>  8973
```

```{r, eval = FALSE}
# Vamos arrumar algumas linhas avaliando as distâncias
# entre os nomes das músicas
library(RecordLinkage)

# O que tem de unmatch entre as bases de letras e acordes 
anti_chords_lyrics <- chords %>% dplyr::anti_join(lyrics, by = "song") 

# Salvando os nomes para corrigir
names_to_fix <- anti_chords_lyrics %>% 
  dplyr::distinct(song) %>% 
  dplyr::pull(song)

# Calculando as 'distâncias' entre as músicas da base de letras e as que deram
# unmatch na base de acordes
dists <- lyrics$song %>% 
  purrr::map(levenshteinSim, str1 = names_to_fix)

# Encontrando os nomes de músicas mais similares nas duas bases
ordered_dists <- dists %>% purrr::map_dbl(max)
max_dists <- dists %>% purrr::map_dbl(which.max)

# Filtrando as que tem similaridade > 0.70
indexes_min_dist <- which(ordered_dists > 0.70)
songs_min_dist <- lyrics$song[indexes_min_dist]
index_lyrics <- max_dists[which(ordered_dists > 0.70)]
```

---


```{r, eval = FALSE}
# Salvando as mais similares em um data.frame 
results_dist_lyrics <- data.frame(from_chords = names_to_fix[index_lyrics],
                                  from_lyrics = songs_min_dist)

```

**Exemplos de casos muito similares encontrados:**

*a bela a fera*  e *a bela e a fera*, 

*logo eu* e *logo eu?*, 

*não fala de maria* e *não fala de maria*,

... 

---

# Alterando os dados muito similares

```{r, eval = FALSE}
chords <- chords %>% 
  dplyr::mutate(
    song = 
      dplyr::case_when( 
        song == 'a bela a fera' ~ 'a bela e a fera',  
        song == 'a historia de lily braun' ~ 'a história de lily braun',  
        song == 'a moca do sonho' ~ 'a moça do sonho',  
        song == 'a ostra o vento' ~ 'a ostra e o vento',  
        song == 'a televisao' ~ 'a televisão',  
        song == 'a valsa dos clows' ~ 'a valsa dos clowns',  
        song == 'a voz do dono o dono da voz' ~ 'a voz do dono e o dono da voz',  
        song == 'agora falando serio' ~ 'agora falando sério',  
        TRUE ~ song))

```

Como criar a sintaxe anterior facilmente: 
```{r, eval = FALSE}
cat(
  paste0("song == ", "'", results_dist_lyrics$from_chords, "' ~ '", 
         results_dist_lyrics$from_lyrics, "', "), collapse = "")

```

---

# Refazendo os `joins`

```{r}
all_data <- chords %>% 
  dplyr::inner_join(lyrics, by = "song") %>% 
  dplyr::inner_join(features, by = "song")

# Salvando os dados!
write.table(all_data, "all_data.txt")
```

---

class: bottom, center, inverse

# Análise Exploratória

---

# Parte 1: letras

Pacotes extra:
  - `tm`
  - `tidytext`
  - `lexiconPT`
  

```{r, echo = FALSE, eval = TRUE}
all_data <- read.table("all_data.txt", stringsAsFactors = FALSE)
```


```{r, eval = TRUE}
library(tidytext)
library(wordcloud)

# Lista de stopwords em português
stopwords_pt <- data.frame(word = tm::stopwords("portuguese"))

# Quebrando as frase em palavras 
unnested <- all_data %>% 
  select(text) %>% 
  unnest_tokens(word, text) %>% 
  # Removendo stopwords
  dplyr::anti_join(stopwords_pt, by = c("word" = "word"))
```

---

# Parte 1: letras

Contando cada palavra que apareceu nas letras: 
```{r, eval = TRUE}
unnested %>% 
  dplyr::count(word) %>% 
  arrange(desc(n)) %>% 
  slice(1:10)

```

---

# 1-grams 

```{r, eval = FALSE}
unnested %>% 
  dplyr::count(word) %>% 
  dplyr::filter(n < quantile(n, 0.999)) %>% 
  dplyr::top_n(n = 30) %>% 
  ggplot(aes(reorder(word, n), n)) +
  geom_linerange(aes(ymin = min(n), ymax = n, x = reorder(word, n)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  coord_flip() +
  labs(x = 'Top 30 palavras mais comuns', y = 'Contagem') +
  theme_bw()
```


---
# 1-grams 

```{r, fig.width=5.5, fig.height=6, echo = FALSE, eval = TRUE}
unnested %>% 
  dplyr::count(word) %>% 
  dplyr::filter(n < quantile(n, 0.999)) %>% 
  dplyr::top_n(n = 30) %>% 
  ggplot(aes(reorder(word, n), n)) +
  geom_linerange(aes(ymin = min(n), ymax = n, x = reorder(word, n)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  coord_flip() +
  labs(x = 'Top 30 palavras mais comuns', y = 'Contagem') +
  theme_bw()
```

---
# Em formato de `wordcloud`

```{r, eval = TRUE, fig.width=5, fig.height=5, fig.align="center"}
unnested %>% 
  count(word) %>% 
  with(wordcloud(word, n, family = "serif", 
                 random.order = FALSE, max.words = 30, 
                 colors = c("darksalmon", "dodgerblue4")))
```


---

# 2-grams 

```{r, eval = FALSE}
all_data %>% 
  select(text) %>% 
  unnest_tokens(bigram, text, token = "ngrams", n = 2) %>%
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(!word1 %in% stopwords_pt$word, 
         !is.na(word1), !is.na(word2),
         !word2 %in% stopwords_pt$word) %>%
  count(word1, word2, sort = TRUE) %>% 
  mutate(word = paste(word1, word2)) %>% 
  filter(n < quantile(n, 0.999)) %>% 
  arrange(desc(n)) %>% 
  slice(1:30) %>%  
  ggplot(aes(reorder(word, n), n)) +
  geom_linerange(aes(ymin = min(n), ymax = n, x = reorder(word, n)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  coord_flip() +
  labs(x = 'Top 30 most common 2-grams', y = 'Counts') +
  theme_bw()
```


---

```{r, eval = TRUE, echo = FALSE}
all_data %>% 
  select(text) %>% 
  unnest_tokens(bigram, text, token = "ngrams", n = 2) %>%
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(!word1 %in% stopwords_pt$word, 
         !is.na(word1), !is.na(word2),
         !word2 %in% stopwords_pt$word) %>%
  count(word1, word2, sort = TRUE) %>% 
  mutate(word = paste(word1, word2)) %>% 
  filter(n < quantile(n, 0.999)) %>% 
  arrange(desc(n)) %>% 
  slice(1:30) %>%  
  ggplot(aes(reorder(word, n), n)) +
  geom_linerange(aes(ymin = min(n), ymax = n, x = reorder(word, n)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  coord_flip() +
  labs(x = 'Top 30 2-grams mais comuns', y = 'Contagem') +
  theme_bw()


```

---

# Análise de sentimentos

```{r, eval = TRUE}
# devtools::install_github("sillasgonzaga/lexiconPT")

# Buscando os sentimentos do pacote lexiconPT
sentiments_pt <- lexiconPT::oplexicon_v2.1 %>% 
  mutate(word = term) %>% 
  select(word, polarity)  

# Juntando os sentimentos com as palavras presentes nas músicas
add_sentiments <- all_data %>% 
  select(text, song) %>% 
  group_by_all() %>% 
  slice(1) %>% 
  ungroup() %>% 
  unnest_tokens(word, text) %>% 
  dplyr::anti_join(stopwords_pt, by = c("word" = "word")) %>% 
  dplyr::inner_join(sentiments_pt, by = c("word" = "word")) 
```

---

```{r}
add_sentiments %>% 
  group_by(polarity) %>% 
  count(word) %>% 
  filter(n < quantile(n, 0.999)) %>% 
  top_n(n = 15) %>% 
  ggplot(aes(reorder(word, n), n)) +
  geom_linerange(aes(ymin = min(n), ymax = n, x = reorder(word, n)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  facet_wrap(~polarity, scales = "free") +
  coord_flip() +
    labs(x = 'Top 15 palavras mais comuns', 
       y = 'Contagens', title = "Sentimentos") +
  theme_bw()
```


---

```{r, echo = FALSE, eval = TRUE}
add_sentiments %>% 
  group_by(polarity) %>% 
  count(word) %>% 
  filter(n < quantile(n, 0.999)) %>% 
  top_n(n = 15) %>% 
  ggplot(aes(reorder(word, n), n)) +
  geom_linerange(aes(ymin = min(n), ymax = n, x = reorder(word, n)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  facet_wrap(~polarity, scales = "free") +
  coord_flip() +
  labs(x = 'Top 15 palavras mais comuns', 
       y = 'Contagens', title = "Sentimentos") +
  theme_bw()

```

---

# Quais são as músicas mais negativas e mais positivas?

```{r}
summ <- add_sentiments %>% 
  group_by(song) %>% 
  summarise(mean_pol = mean(polarity)) 

# Most positive and most negative songs
summ %>% 
  arrange(desc(mean_pol)) %>% 
  slice(c(1:15, 121:135)) %>% 
  mutate(situation = rep(c('+positivas', '+negativas'), each = 15)) %>% 
  ggplot(aes(reorder(song, mean_pol), mean_pol)) +
  geom_linerange(aes(ymin = min(mean_pol), ymax = mean_pol, 
                     x = reorder(song, mean_pol)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  facet_wrap(~situation, scales = "free") +
  coord_flip() +
  labs(x = 'Músicas', y = 'Polaridades') +
  theme_bw()
```

---


--- 

```{r, eval = TRUE, echo = FALSE}
summ <- add_sentiments %>% 
  group_by(song) %>% 
  summarise(mean_pol = mean(polarity)) 

summ %>% 
  arrange(desc(mean_pol)) %>% 
  slice(c(1:15, 121:135)) %>% 
  mutate(situation = rep(c('+positivas', '+negativas'), each = 15)) %>% 
  ggplot(aes(reorder(song, mean_pol), mean_pol)) +
  geom_linerange(aes(ymin = min(mean_pol), ymax = mean_pol, 
                     x = reorder(song, mean_pol)),
                 position = position_dodge(width = 0.2), size = 1, 
                 colour = 'darksalmon') + 
  geom_point(colour = 'dodgerblue4', size = 3, alpha = 0.9) +
  facet_wrap(~situation, scales = "free") +
  coord_flip() +
  labs(x = 'Músicas', y = 'Polaridades') +
  theme_bw()
```


---

# Parte 2. Acordes

Pacotes extra:
  - `ggridges`
  - `chorddiag`

---

# Parte 2. Acordes

```{r}
# Removendo enarmonias
chords <- all_data %>%
  select(chord, song) %>% 
  dplyr::mutate(chord = case_when( 
    chord == "Gb" ~ "F#",
    chord == "C#" ~ "Db",          
    chord == "G#" ~ "Ab",
    chord == "A#" ~ "Bb",
    chord == "D#" ~ "Eb",
    chord == "E#" ~ "F",
    chord == "B#" ~ "C",
    TRUE ~ chord)) 

# Top 20 músicas com uma maior quantidade de acordes
chords %>% 
  dplyr::group_by(song, chord) %>% 
  dplyr::summarise(distintos = n_distinct(chord)) %>% 
  dplyr::summarise(cont = n()) %>% 
  dplyr::mutate(song = fct_reorder(song, cont)) %>% 
  top_n(n = 20) %>% 
  ggplot(aes(y = cont, x = song)) +
  geom_bar(colour = 'dodgerblue4', fill = 'darksalmon',
           size = 0.5, alpha = 0.6, stat = "identity") +
  labs(x = 'Músicas', y = 'Contagem de Acordes Distintos') +
  coord_flip() +
  theme_bw()


```

---

```{r, echo = FALSE, eval = TRUE}
# Removendo enarmonias
chords <- all_data %>%
  select(chord, song) %>% 
  dplyr::mutate(chord = case_when( 
    chord == "Gb" ~ "F#",
    chord == "C#" ~ "Db",          
    chord == "G#" ~ "Ab",
    chord == "A#" ~ "Bb",
    chord == "D#" ~ "Eb",
    chord == "E#" ~ "F",
    chord == "B#" ~ "C",
    TRUE ~ chord)) 

# Top 20 músicas com uma maior quantidade de acordes
chords %>% 
  dplyr::group_by(song, chord) %>% 
  dplyr::summarise(distintos = n_distinct(chord)) %>% 
  dplyr::summarise(cont = n()) %>% 
  dplyr::mutate(song = fct_reorder(song, cont)) %>% 
  top_n(n = 20) %>% 
  ggplot(aes(y = cont, x = song)) +
  geom_bar(colour = 'dodgerblue4', fill = 'darksalmon',
           size = 0.5, alpha = 0.6, stat = "identity") +
  labs(x = 'Músicas', y = 'Contagem de Acordes Distintos') +
  coord_flip() +
  theme_bw()

```

---
# Extraindo variáveis dos acordes

```{r, eval = TRUE}
feat_chords <- all_data %>%
  select(chord, song) %>% 
  chorrrds::feature_extraction() %>% 
  select(-chord) %>% 
  group_by(song) %>% 
  summarise_all(mean)

dt <- feat_chords %>% 
  tidyr::gather(group, vars, minor, seventh, 
                seventh_M, sixth, fifth_dim, fifth_aug, 
                fourth, ninth, bass, dimi, augm)
```


---
# Extraindo variáveis dos acordes

```{r, eval = TRUE}
glimpse(feat_chords)
```

---

```{r}
library(ggridges)

dt$group <- forcats::lvls_revalue(
  dt$group,
  c("Augmented", "Bass", "Diminished", 
    "Aug. Fifth", "Dim. Fifth", 
    "Fourth", "Minor", "Ninth", "Seventh",
    "Major Seventh", "Sixth"))

# Plotting densities of the extracted features
dt %>% 
  ggplot(aes(vars, group, fill = group)) +
  geom_density_ridges(alpha = 0.6) +
  scale_fill_cyclical(values = c("dodgerblue4", "darksalmon")) +
  guides(fill = FALSE) +
  xlim(0, 1) +
  labs(x = "Densities", y = "Extracted variables") +
  theme_bw()

```

---

```{r, eval = TRUE, echo = FALSE}
library(ggridges)

dt$group <- forcats::lvls_revalue(
  dt$group,
  c("Augmented", "Bass", "Diminished", 
    "Aug. Fifth", "Dim. Fifth", 
    "Fourth", "Minor", "Ninth", "Seventh",
    "Major Seventh", "Sixth"))

# Plotting densities of the extracted features
dt %>% 
  ggplot(aes(vars, group, fill = group)) +
  geom_density_ridges(alpha = 0.6) +
  scale_fill_cyclical(values = c("dodgerblue4", "darksalmon")) +
  guides(fill = FALSE) +
  xlim(0, 1) +
  labs(x = "Densities", y = "Extracted variables") +
  theme_bw()

```

---

# Diagramas de cordas

```{r}
# Contando as transições entre os acordes
comp <- chords %>% 
  dplyr::mutate(
    # Colocando os acordes na forma mais simples
    chord_clean = stringr::str_extract(chord, pattern = "^([A-G]#?b?)"),
    seq = lead(chord_clean)) %>% 
  dplyr::filter(chord_clean != seq) %>% 
  dplyr::group_by(chord_clean, seq) %>%  
  dplyr::summarise(n = n())

mat <- tidyr::spread(comp, key = chord_clean, value = n, fill = 0)  
mm <- as.matrix(mat[, -1]) 

# Construindo o diagrama
chorddiag::chorddiag(mm, showTicks = FALSE,
                     palette = "Blues")

```

---

# Diagramas de cordas

```{r, eval = TRUE, echo = FALSE, fig.align="center"}
# Contando as transições entre os acordes
comp <- chords %>% 
  dplyr::mutate(
    # Colocando os acordes na forma mais simples
    chord_clean = stringr::str_extract(chord, pattern = "^([A-G]#?b?)"),
    seq = lead(chord_clean)) %>% 
  dplyr::filter(chord_clean != seq) %>% 
  dplyr::group_by(chord_clean, seq) %>%  
  dplyr::summarise(n = n())

mat <- tidyr::spread(comp, key = chord_clean, value = n, fill = 0)  
mm <- as.matrix(mat[, -1]) 

# Construindo o diagrama
chorddiag::chorddiag(mm, showTicks = FALSE,
                     palette = "Blues")

```


---

# Parte 3. Variáveis do Spotify

```{r}
spot <- all_data %>% 
  group_by(song) %>% 
  slice(1) %>% 
  ungroup()

# Densidade da popularidade das músicas
spot %>% 
  ggplot(aes(popul)) +
  geom_density(colour = 'dodgerblue4',
               fill = "darksalmon", 
               alpha = 0.8) +
  labs(x = "Popularidade", y = "Densidade") +
  theme_bw()
```

---

```{r, eval = TRUE, echo = FALSE}
spot <- all_data %>% 
  group_by(song) %>% 
  slice(1) %>% 
  ungroup()

# Densidade da popularidade das músicas
spot %>% 
  ggplot(aes(popul)) +
  geom_density(colour = 'dodgerblue4',
               fill = "darksalmon", 
               alpha = 0.8) +
  labs(x = "Popularidade", y = "Densidade") +
  theme_bw()
```

---

# Músicas mais e menos populares

```{r}
spot %>% 
  arrange(desc(popul)) %>%  
  slice(c(1:15, 121:135)) %>% 
  mutate(situation = rep(c('+popul', '-popul'), each = 15)) %>% 
  select(popul, situation, song) %>% 
  ggplot(aes(reorder(song, popul), popul, group = 1)) +
  geom_bar(colour = 'dodgerblue4',  fill = "darksalmon", 
           size = 0.3, alpha = 0.6, 
           stat = "identity") +
  facet_wrap(~situation, scales = "free") +
  coord_flip() +
  labs(x = 'Músicas', y = 'Popularidade') +
  theme_bw()
```

---


```{r, eval = TRUE, echo = FALSE}
spot %>% 
  arrange(desc(popul)) %>%  
  slice(c(1:15, 121:135)) %>% 
  mutate(situation = rep(c('+popul', '-popul'), each = 15)) %>% 
  select(popul, situation, song) %>% 
  ggplot(aes(reorder(song, popul), popul, group = 1)) +
  geom_bar(colour = 'dodgerblue4',  fill = "darksalmon", 
           size = 0.3, alpha = 0.6, 
           stat = "identity") +
  facet_wrap(~situation, scales = "free") +
  coord_flip() +
  labs(x = "Dançabilidade", y = "Variáveis") +
  theme_bw()

```

---

# Dançabilidade `x` as outras variáveis

```{r}
dt <- spot %>% 
  select(energy,  
          loudness, speechiness, liveness, duration_ms, 
          acousticness) %>% 
  tidyr::gather(group, vars) 

dt$danceability <- spot$danceability

dt %>% 
ggplot(aes(danceability, vars)) +
  geom_point(colour = "darksalmon") +  
  geom_smooth(method  = "lm", colour = "dodgerblue4") +
  labs(x = "Dançabilidade", y = "Variáveis") +
  facet_wrap(~group, scales = "free") +
  theme_bw()

```

---

```{r, eval = TRUE, echo = FALSE}
dt <- spot %>% 
  select(energy,  
          loudness, speechiness, liveness, duration_ms, 
          acousticness) %>% 
  tidyr::gather(group, vars) 

dt$danceability <- spot$danceability

dt %>% 
ggplot(aes(danceability, vars)) +
  geom_point(colour = "darksalmon") +  
  geom_smooth(method  = "lm", colour = "dodgerblue4") +
  labs(x = "Dançabilidade", y = "Variáveis") +
  facet_wrap(~group, scales = "free") +
  theme_bw()

```


---

class: bottom, center, inverse

# Modelagem

---

# Modelagem

Vamos considerar agora que temos um interesse especial na popularidade
das músicas. Quais variáveis seriam mais associadas com altos ou baixos
níveis de popularidade?

Para começar, transformamos a popularidade em uma variável
de 3 classes:

```{r, eval = TRUE}
library(randomForest)

spot <- spot %>% 
  mutate(pop_class = ifelse(
    popul < quantile(popul, 0.33), "pouco popular",
    ifelse(popul < quantile(popul, 0.66), "neutro", "popular")))

spot %>% 
  janitor::tabyl(pop_class)
```

---
**Arrumando os dados a fim de deixá-los prontos para a modelagem**

```{r, eval = TRUE}
# Unindo as bases anteriores e arrumando
model_data <- feat_chords %>% 
  right_join(spot, by = c("song" = "song")) %>% 
  right_join(summ, by = c("song" = "song")) %>% 
  select(-analysis_url, -uri, -id.x, -id.y, -song, 
         -name, -text, -lang, -chord, -long_str,
         -key.x, -song.id, -sus, 
         -popul) %>% 
  mutate(pop_class = as.factor(pop_class)) %>% 
  # Separando em treino e teste
  mutate(part = ifelse(runif(nrow(.)) > 0.25, "treino", "teste"))

model_data %>% 
  janitor::tabyl(part)
```

---

Separando em base de treino (75%) e teste (25%):
```{r, eval = TRUE}
train <- model_data %>% 
  filter(part == "treino") %>% 
  select(-part)

test <- model_data %>% 
  filter(part == "teste") %>% 
  select(-part)
```

O modelo vai ser do tipo:

` pop_class ~ minor + dimi + augm + seventh + seventh_M + sixth + fourth + fifth_aug + fifth_dim + ninth + bass + danceability + energy + key.y + loudness + mode + speechiness + acousticness + instrumentalness + liveness + valence + tempo + duration_ms + time_signature + mean_pol `

---

```{r, eval = TRUE}
m0 <- randomForest(pop_class ~ ., data = train, 
                   ntree = 1000)
m0
```

---
**Visualizando a importância das variáveis**
```{r}
imp0 <- randomForest::importance(m0)
imp0 <- data.frame(var = dimnames(imp0)[[1]], 
                   value = c(imp0))

imp0 %>% 
  arrange(var, value) %>% 
  mutate(var = fct_reorder(factor(var),  value,  min)) %>% 
  ggplot(aes(var, value)) +
  geom_point(size = 3.5, colour = "darksalmon") +
  coord_flip() +
  labs(
       x = "Variáveis", y = "Diminuição no critério de Gini") +
  theme_bw()

```

---
**Visualizando a importância das variáveis**
```{r, eval = TRUE, echo = FALSE}
imp0 <- randomForest::importance(m0)
imp0 <- data.frame(var = dimnames(imp0)[[1]], 
                   value = c(imp0))

imp0 %>% 
  arrange(var, value) %>% 
  mutate(var = fct_reorder(factor(var),  value,  min)) %>% 
  ggplot(aes(var, value)) +
  geom_point(size = 3.5, colour = "darksalmon") +
  coord_flip() +
  labs(
       x = "Variáveis", y = "Diminuição no critério de Gini") +
  theme_bw()

```

---
# Medindo a acurácia na base de teste

```{r, eval = TRUE}
pred <- predict(m0, test)

sum(pred == test$pop_class)/nrow(test)
mean(m0$err.rate[,1])
```

**Como melhorar o modelo?**

```{r}
corrplot::corrplot(cor(train %>% select_if(is.numeric), method = "spearman"))
```


---

---

---
class: bottom, center, inverse

<font size="30">Obrigada! </font>


